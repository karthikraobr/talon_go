/*
Integration API reference docs

Use the Integration API to push data to and retrieve data from Talon.One in real time. For more background information about this API, see [Integration API overview](/docs/dev/integration-api/overview)  For example, use this API to share shopping cart information as a session with Talon.One and evaluate promotion rules. You can also create custom events to track specific actions that do not fit into the session data model.  Ensure you [authenticate](#section/Authentication) to make requests to the API.  <div class=\"redoc-section\">   <p class=\"title\">Are you looking for a different API?</p>    If you need the API to:    - Interact with the Campaign Manager for backoffice operations, see [the Management API reference docs](https://docs.talon.one/management-api).   - Integrate with Talon.One from a CEP or CDP platform, see [the Third-party API reference docs](https://docs.talon.one/third-party-api).  </div>  # Authentication  <SecurityDefinitions /> 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package talon

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// CustomerSessionsApiService CustomerSessionsApi service
type CustomerSessionsApiService service

type ApiGetCustomerSessionRequest struct {
	ctx context.Context
	ApiService *CustomerSessionsApiService
	customerSessionId string
}

func (r ApiGetCustomerSessionRequest) Execute() (*IntegrationCustomerSessionResponse, *http.Response, error) {
	return r.ApiService.GetCustomerSessionExecute(r)
}

/*
GetCustomerSession Get customer session

Get the details of the given customer session.

You can get the same data via other endpoints that also apply changes, which can help you save requests and increase performance. See:

- [Update customer session](#tag/Customer-sessions/operation/updateCustomerSessionV2)
- [Update customer profile](#tag/Customer-profiles/operation/updateCustomerProfileV2)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerSessionId The `integration ID` of the customer session. You set this ID when you create a customer session.  You can see existing customer session integration IDs in the Campaign Manager's **Sessions** menu, or via the [List Application session endpoint](https://docs.talon.one/management-api/#operation/getApplicationSessions). 
 @return ApiGetCustomerSessionRequest
*/
func (a *CustomerSessionsApiService) GetCustomerSession(ctx context.Context, customerSessionId string) ApiGetCustomerSessionRequest {
	return ApiGetCustomerSessionRequest{
		ApiService: a,
		ctx: ctx,
		customerSessionId: customerSessionId,
	}
}

// Execute executes the request
//  @return IntegrationCustomerSessionResponse
func (a *CustomerSessionsApiService) GetCustomerSessionExecute(r ApiGetCustomerSessionRequest) (*IntegrationCustomerSessionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationCustomerSessionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerSessionsApiService.GetCustomerSession")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/customer_sessions/{customerSessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"customerSessionId"+"}", url.PathEscape(parameterToString(r.customerSessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_v1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseWithStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnCartItemsRequest struct {
	ctx context.Context
	ApiService *CustomerSessionsApiService
	customerSessionId string
	body *ReturnIntegrationRequest
	dry *bool
}

func (r ApiReturnCartItemsRequest) Body(body ReturnIntegrationRequest) ApiReturnCartItemsRequest {
	r.body = &body
	return r
}

// Indicates whether to persist the changes. Changes are ignored when &#x60;dry&#x3D;true&#x60;.
func (r ApiReturnCartItemsRequest) Dry(dry bool) ApiReturnCartItemsRequest {
	r.dry = &dry
	return r
}

func (r ApiReturnCartItemsRequest) Execute() (*IntegrationStateV2, *http.Response, error) {
	return r.ApiService.ReturnCartItemsExecute(r)
}

/*
ReturnCartItems Return cart items

Create a new return request for the specified cart items.

This endpoint automatically changes the session state from `closed` to `partially_returned`.

Its behavior depends on whether [cart item flattening](https://docs.talon.one/docs/product/campaigns/campaign-evaluation/#flattened-cart-items)
is enabled for the Application.

**Note:** This will roll back any effects associated with these cart items. For more information, see
[our documentation on session states](https://docs.talon.one/docs/dev/concepts/entities#customer-session-states)
and [this tutorial](https://docs.talon.one/docs/dev/tutorials/partially-returning-a-session).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerSessionId The `integration ID` of the customer session. You set this ID when you create a customer session.  You can see existing customer session integration IDs in the Campaign Manager's **Sessions** menu, or via the [List Application session endpoint](https://docs.talon.one/management-api/#operation/getApplicationSessions). 
 @return ApiReturnCartItemsRequest
*/
func (a *CustomerSessionsApiService) ReturnCartItems(ctx context.Context, customerSessionId string) ApiReturnCartItemsRequest {
	return ApiReturnCartItemsRequest{
		ApiService: a,
		ctx: ctx,
		customerSessionId: customerSessionId,
	}
}

// Execute executes the request
//  @return IntegrationStateV2
func (a *CustomerSessionsApiService) ReturnCartItemsExecute(r ApiReturnCartItemsRequest) (*IntegrationStateV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationStateV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerSessionsApiService.ReturnCartItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/customer_sessions/{customerSessionId}/returns"
	localVarPath = strings.Replace(localVarPath, "{"+"customerSessionId"+"}", url.PathEscape(parameterToString(r.customerSessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dry != nil {
		localVarQueryParams.Add("dry", parameterToString(*r.dry, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_v1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseWithStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCustomerSessionV2Request struct {
	ctx context.Context
	ApiService *CustomerSessionsApiService
	customerSessionId string
	body *IntegrationRequest
	dry *bool
}

func (r ApiUpdateCustomerSessionV2Request) Body(body IntegrationRequest) ApiUpdateCustomerSessionV2Request {
	r.body = &body
	return r
}

// Indicates whether to persist the changes. Changes are ignored when &#x60;dry&#x3D;true&#x60;.
func (r ApiUpdateCustomerSessionV2Request) Dry(dry bool) ApiUpdateCustomerSessionV2Request {
	r.dry = &dry
	return r
}

func (r ApiUpdateCustomerSessionV2Request) Execute() (*IntegrationStateV2, *http.Response, error) {
	return r.ApiService.UpdateCustomerSessionV2Execute(r)
}

/*
UpdateCustomerSessionV2 Update customer session

Update or create a [customer session](/docs/dev/concepts/entities#customer-session).
For example, use this endpoint to share the content of a customer's cart with Talon.One and to check which
promotion rules apply.

**Note:** The currency for the session and the cart items in the session is the same as the
Application that owns this session.

### Session management

The Talon.One platform supports multiple simultaneous sessions for the same profile. If you have multiple ways of accessing the same Application you can either:

- Track multiple independent sessions or,
- Use the same session across all of them.

You should share sessions when application access points share other state, such as the user's cart.
If two points of access to the application have independent states, for example a user can have different
items in their cart across the two) they should use independent customer session ID's.

See more information and tips about session management in the [documentation](/docs/dev/concepts/entities#customer-session).

### Sessions and customer profiles

- To link a session to a customer profile, set the `profileId` parameter in the request body to a customer profile's `integrationId`.
- While you can create an anonymous session with `profileId=""`, we recommend you use a guest ID instead.

**Note:** You do **not** have to create a customer profile first. If the specified profile does not exist, an empty profile is created automatically.

<div class="redoc-section">
  <p class="title">Performance tips</p>

  Updating a customer session returns a response with the requested integration state. Use the `responseContent` property to save yourself extra API calls. For example, you can get
  the customer profile details directly without extra requests.

  For more information, see the [integration tutorial](https://docs.talon.one/docs/dev/tutorials/integrating-talon-one).
</div>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param customerSessionId The `integration ID` of the customer session. You set this ID when you create a customer session.  You can see existing customer session integration IDs in the Campaign Manager's **Sessions** menu, or via the [List Application session endpoint](https://docs.talon.one/management-api/#operation/getApplicationSessions). 
 @return ApiUpdateCustomerSessionV2Request
*/
func (a *CustomerSessionsApiService) UpdateCustomerSessionV2(ctx context.Context, customerSessionId string) ApiUpdateCustomerSessionV2Request {
	return ApiUpdateCustomerSessionV2Request{
		ApiService: a,
		ctx: ctx,
		customerSessionId: customerSessionId,
	}
}

// Execute executes the request
//  @return IntegrationStateV2
func (a *CustomerSessionsApiService) UpdateCustomerSessionV2Execute(r ApiUpdateCustomerSessionV2Request) (*IntegrationStateV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IntegrationStateV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CustomerSessionsApiService.UpdateCustomerSessionV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/customer_sessions/{customerSessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"customerSessionId"+"}", url.PathEscape(parameterToString(r.customerSessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dry != nil {
		localVarQueryParams.Add("dry", parameterToString(*r.dry, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["api_key_v1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseWithStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
