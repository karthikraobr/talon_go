/*
Integration API reference docs

Use the Integration API to push data to and retrieve data from Talon.One in real time. For more background information about this API, see [Integration API overview](/docs/dev/integration-api/overview)  For example, use this API to share shopping cart information as a session with Talon.One and evaluate promotion rules. You can also create custom events to track specific actions that do not fit into the session data model.  Ensure you [authenticate](#section/Authentication) to make requests to the API.  <div class=\"redoc-section\">   <p class=\"title\">Are you looking for a different API?</p>    If you need the API to:    - Interact with the Campaign Manager for backoffice operations, see [the Management API reference docs](https://docs.talon.one/management-api).   - Integrate with Talon.One from a CEP or CDP platform, see [the Third-party API reference docs](https://docs.talon.one/third-party-api).  </div>  # Authentication  <SecurityDefinitions /> 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package talon

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// CatalogsApiService CatalogsApi service
type CatalogsApiService service

type ApiSyncCatalogRequest struct {
	ctx context.Context
	ApiService *CatalogsApiService
	catalogId int32
	body *CatalogSyncRequest
}

func (r ApiSyncCatalogRequest) Body(body CatalogSyncRequest) ApiSyncCatalogRequest {
	r.body = &body
	return r
}

func (r ApiSyncCatalogRequest) Execute() (*Catalog, *http.Response, error) {
	return r.ApiService.SyncCatalogExecute(r)
}

/*
SyncCatalog Sync cart item catalog

Perform one or more of the following sync actions on this cart item catalog, up to 1000 actions:

- Add an item to the catalog.
- Edit the attributes of an item in the catalog.
- Edit the attributes of more than one item in the catalog.
- Remove an item from the catalog.
- Remove more than one item from the catalog.

**Note**: For more information, see [our documentation on managing cart item catalogs](https://docs.talon.one/docs/product/account/dev-tools/managing-cart-item-catalogs).

### Filtering cart items

Use [cart item attributes](https://docs.talon.one/docs/product/account/dev-tools/managing-cart-item-catalogs#displaying-the-details-and-content-of-a-catalog)
to filter items and select the ones you want to edit or delete when editing or deleting more than one item
at a time.

The `filters` object contains the following properties:

- `attr`: A [cart item attribute](https://docs.talon.one/docs/product/account/dev-tools/managing-attributes)
  connected to the catalog. It is applied to all items in the catalog.
- `op`: The filtering operator indicating the relationship between the value of each
  cart item in the catalog and the value of the `value` property for the attribute selected
  in `attr`.

  The value of `op` can be one of the following:

  - `EQ`: Equal to `value`
  - `LT`: Less than `value`
  - `LE`: Less than or equal to `value`
  - `GT`: Greater than `value`
  - `GE`: Greater than or equal to `value`
  - `IN`: One of the comma-separated values that `value` is set to.

  **Note:** `GE`, `LE`, `GT`, `LT` are for numeric values only.

- `value`: The value of the attribute selected in `attr`.

### Payload examples

Synchronization actions are sent as `PUT` requests. See the structure for each action:

<details>
  <summary><strong>Adding an item to the catalog</strong></summary>
  <div>

  ```json
  {
    "actions": [
      {
        "payload": {
          "attributes": {
            "color": "Navy blue",
            "type": "shoe"
          },
          "replaceIfExists": true,
          "sku": "SKU1241028"
        },
        "type": "ADD"
      }
    ]
  }
  ```
  </div>
</details>

<details>
  <summary><strong>Editing the attributes of an item in the catalog</strong></summary>
  <div>

  ```json
  {
    "actions": [
      {
        "payload": {
          "attributes": {
            "age": 11,
            "origin": "germany"
          },
          "createIfNotExists": false,
          "sku": "SKU1241028"
        },
        "type": "PATCH"
      }
    ]
  }
  ```
  </div>
</details>

<details>
  <summary><strong>Editing the attributes of several items at once</strong></summary>
  <div>

  ```json
  {
    "actions": [
      {
        "payload": {
          "attributes": {
            "color": "red"
          },
          "filters": [
            {
              "attr": "color",
              "op": "EQ",
              "value": "blue"
            }
          ]
        },
        "type": "PATCH_MANY"
      }
    ]
  }
  ```

  </div>
</details>

<details>
  <summary><strong>Removing an item from the catalog</strong></summary>
  <div>

  ```json
  {
    "actions": [
      {
        "payload": {
          "sku": "SKU1241028"
        },
        "type": "REMOVE"
      }
    ]
  }
  ```

  </div>
</details>

<details>
  <summary><strong>Removing several items from the catalog at once</strong></summary>
  <div>

  ```json
  {
    "actions": [
      {
        "payload": {
          "filters": [
            {
              "attr": "color",
              "op": "EQ",
              "value": "blue"
            }
          ]
        },
        "type": "REMOVE_MANY"
      }
    ]
  }
  ```
  </div>
</details>

<details>
  <summary><strong>Removing shoes of sizes above 45 from the catalog</strong></summary>
  <div>
  <p>
  Let's imagine that we have a shoe store and we have decided to stop selling
  shoes larger than size 45. We can remove from the catalog all the shoes of sizes above 45
  with a single action:</p>

  ```json
  {
    "actions": [
      {
        "payload": {
          "filters": [
            {
              "attr": "size",
              "op": "GT",
              "value": "45"
            }
          ]
        },
        "type": "REMOVE_MANY"
      }
    ]
  }
  ```
  </div>
</details>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId
 @return ApiSyncCatalogRequest
*/
func (a *CatalogsApiService) SyncCatalog(ctx context.Context, catalogId int32) ApiSyncCatalogRequest {
	return ApiSyncCatalogRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
	}
}

// Execute executes the request
//  @return Catalog
func (a *CatalogsApiService) SyncCatalogExecute(r ApiSyncCatalogRequest) (*Catalog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Catalog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CatalogsApiService.SyncCatalog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/catalogs/{catalogId}/sync"
	localVarPath = strings.Replace(localVarPath, "{"+"catalogId"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseWithStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseWithStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
